## Funciones
Las funciones son bloques de código que poseen un nombre y estan diseñadas para realizar una tarea específica.

Si necesitas realizar una tarea multiples veces crear una función y "llamarla" es una buena práctica para evitar reescribir código.

las funciones también pueden tomar información, procesarla y generar un salida o retorno.

def saludar_usuario():
    print("Hola!!!")

saludar_usuario()

### Pasando información a una función
Las funciones pueden tomar <b>parámetros</b> de entrada, como ejemplo podemos modificar la función anterior para saludar al usuario. Simplemente pasamos
el nombre de usuario como parámetro de la función.

def saludar_usuario(nombre_usuario):
    print("Hola", nombre_usuario.title(), "!!!")

saludar_usuario('Leonel')

### Argumentos y parámetros
En la función anterior <b>nombre_usuario</b> es un <b>parámetro</b> mientras que 'Leonel' es un <b>argumento</b>

### Múltiples llamadas a una función
Una función puede ser llamada multiples veces cambiando los argumentos que se envian a esta.

def describir_mascota(tipo_animal, nombre):
    print("Esto es un",tipo_animal)
    print("Su nombre es",nombre.title())

describir_mascota('perro','firulais')
describir_mascota('gato','bola de nieve')
# recuerda que el orden los argumentos es importante
describir_mascota('Raul','Pez')

### Argumentos con palabra clave
Un argumento con palabra clave es un argumento pasado pares de nombre/valor. Usados comunmente para evitar problemas con el orden en el que se llaman
los argumentos de una función.

def describir_mascota(tipo_animal, nombre):
    print("Esto es un",tipo_animal)
    print("Su nombre es",nombre.title())

describir_mascota(nombre='Raul', tipo_animal='Pez')

### Valores por defecto
Cuando escribes una función es posible definir un <b>valor por defecto</b> para cada parámetro. Si un argumento para un parámetro es usado al momento de llamar
a la función, Python usa el argumento enviado, si no es así, Python usa el valor por defecto.

Notese que se debe cambiar el orden de los valores.

def describir_mascota(nombre, tipo_animal='perro'):
    print("Esto es un",tipo_animal)
    print("Su nombre es",nombre.title())

describir_mascota('Buddy')
describir_mascota('Luna', 'pez')

### Valores de retorno
Una función no tiene porque simplemente mostrar valores directamente, también puede procesar alguna data y <b>retornar un valor</b>.

### Retornando un simple valor
def obtener_nombre_formateado(primer_nombre, apellido):
    nombre_completo = primer_nombre + " " + apellido
    return nombre_completo.title()

musico = obtener_nombre_formateado('jimi','hendrix')
print(musico)

### Valores opcionales
Es posible usar los valores por defecto para esto. Veamos un ejemplo:

def obtener_nombre_formateado(primer_nombre, apellido, segundo_nombre = ''):
    if segundo_nombre:
        nombre_completo = primer_nombre + " " + segundo_nombre + " " + apellido    
    else:
        nombre_completo = primer_nombre + " " + apellido
    
    return nombre_completo.title()

musico = obtener_nombre_formateado('jimi','hendrix')
supuesto_profesor = obtener_nombre_formateado('Leonel','Becerra','Eduardo')

print(musico)
print(supuesto_profesor)

### Pasando un número arbitrario de argumentos
A veces no sabemos cuantos argumentos se usaran en una función. En Python es posible permitirle a una función que tome "n" cantidad de parámetros.

def hacer_pizza(*ingredientes):
    print(ingredientes)
    print(ingredientes[0])

hacer_pizza('mozzarella','salsa','pimenton','anchoas')
hacer_pizza('nutella','piña')

El asterisco en el parámetro ingredientes le indica a Python que debe hacer una tupla.

### Mezclando argumentos posicionales y argumentos arbitrarios
Si quieres tener una función que mezcle ambos tipos, debes colocar los argumentos posicionales al inicio y luego los arbitrarios.

def hacer_pizza(tamanho, *ingredientes):
    print("haciendo una pizza de ",str(tamanho),"pulgadas con los siguientes ingredientes:")
    for ingrediente in ingredientes:
        print(ingrediente)

hacer_pizza(15,'mozzarella','salsa')

### Usando argumetnos con palabras clave arbitrarios
A veces será necesario aceptar un numero arbitrario de parametros de los que no sabemos a ciencia cierta cuál será su tipo. En estos
casos es posible aceptar tantos pares "nombre/valor" como sean necesarios.

def crear_perfil(nombre, apellido, **info_del_usuario):
    info_del_usuario['nombre'] = nombre
    info_del_usuario['apellido'] = apellido
    return info_del_usuario

crear_perfil('Leonel','Becerra', trabajo='programador', juega='ajedrez')

### Guardar tus funciones en módulos
Como ya sabemos una de las ventajas de las funciones es que podemos separar el código en distintos modulos que podremos reutilizar luego.

Usualmente las funciones pueden guardarse en un archivo distinto para no "embasurar" demasiado un solo archivo, lo que dificulta programar conforme el proyecto se hace mas grande.

### Importar un módulo entero
Antes de empezar a importar modulos ,creemos uno . . .

Usemos la funcion anterior que hicimos para las pizzas y guardemosla en un archivo llamado "pizza.py"

# pizza.py
def hacer_pizza(tamanho, *ingredientes):
    print("haciendo una pizza de ",str(tamanho),"pulgadas con los siguientes ingredientes:")
    for ingrediente in ingredientes:
        print(ingrediente)

def enviar_pizza(direccion):
    print("Enviando pizza para:", direccion)

Ahora creemos otro archivo llamado "hacer_pizzas.py"

# hacer_pizzas.py
import pizza

pizza.hacer_pizza(16,'mozzarella','Hongos')
pizza.hacer_pizza(16,'mozzarella','Anchoas')

### Importar una funcion específica
También es posible importar una función específica de un módulo

# hacer_pizzas.py

from pizza import hacer_pizza

hacer_pizza(24,'mozzarella','jamon')

## Clases
La programación orientada a objetos (OOP o por sus siglas en español POO) es una de las aproximaciones mas efectivas para desarrollar software.
En la programación orientada a objetos se crean "clases" que representan <b>objetos del mundo real o situaciones</b> y se crean objetos que usen como
"guia" o "plano" a la clase.

La acción de crear un objeto a partir de una clase es conocida como <b>instanciación</b> lo que crea una <b>instancia</b> de una clase.

### Creando una clase . . . La clase "Perro"

# animales.py
class Perro:

    def __init__(self, nombre, edad):
        self.nombre = nombre.title()
        self.edad = edad

    def sentarse(self):
        print(self.nombre,"se ha sentado")

    def sonido(self):
        print("WOOF !")

    def cumpleanos(self):
        self.edad += 1

### El método __init__
Primero debemos tener en cuenta que una función que se encuentre dentro de una clase se conoce como un <b>método</b>

El método <b>__init__</b> es lo que se conoce como un <b>método especial</b> estos se reconocen facilmente por el doble underscore antes y después del nombre del método.

El método especial init tiene como función ejecutarse al momento de crear o mejor dicho <b>instanciar</b> un objeto.

Es normal que en este método se le den valores a los <b>atributos</b> de la clase. En si son variables que estan ligadas a un objeto en particular

### Instanciando una clase

# main.py
from animales import Perro

mi_perro = Perro('firulais',5)
mi_perro.sentarse()
mi_perro.sonido()

### Accesando los atributos de una instancia
Podriamos simplemente hacer algo como 

print(mi_perro.nombre)

### Creando múltiples instancias
Ahora que tenemos una clase es posible crear mas de un objeto. En este caso creemos varios perros !.

# main.py
from animales import Perro

mi_perro = Perro('firulais',5)
tu_perro = Perro('Rolf',15)

tu_perro.sentarse()
mi_perro.sentarse()
mi_perro.cumpleanos()
print(mi_perro.edad)

## Herencia
No siempre es necesario empezar desde 0 al momento de crear una clase. Si la clase que estás escribiendo es una "especialización" de 
una clase que ya está hecha entonces puedes usar la <b>herencia</b>.

Como ejemplo creemos una nueva clase de perro con más metodos!

hagamos un nuevo archivo y demosle el nombre de super_perro.py

# super_perro.py
from animales import Perro

class SuperPerro(Perro):

    def __init__(self, nombre, edad):
        super().__init__(nombre, edad)

    def sonido(self):
        print("Woof Woof WOOF !!!")

    def dar_vueltas(self):
        print(self.nombre, "se ha dado la vuelta")

    def dar_la_pata(self):
        print(self.nombre, "te ha dado la pata !")

# main.py

from animales import Perro
from super_perro import SuperPerro

mi_perro = SuperPerro('firulais',5)
tu_perro = Perro('Rolf',15)

tu_perro.sentarse()
mi_perro.sentarse()
mi_perro.cumpleanos()
print(mi_perro.edad)

tu_perro.sonido()
mi_perro.sonido()

mi_perro.dar_la_pata()

Notese que en SuperPerro <b>redefinimos el metodo sonido</b>. Esta es una de las funcionalidades más usadas en la POO.

### Creando un paquete para nuestras clases
En Python el código es ordenado en <b>paquetes</p>. Para crear un paquete solo es necesario crear un archivo en blanco con el
nombre <b>__init__.py</b>.

Por ejemplo, creemos el paquete animales. para esto creamos una carpeta con el nombre de animales donde colocaremos nuestros 2 archivos 
(super_perro.py y animales.py). Una vez que terminemos de mover los archivos crearemos un archivo en blanco llamado __init__.py.

Ahora modifiquemos a super_perro.py para que importe de forma correcta a Perro.


# super_perro.py
from animales.animales import Perro

class SuperPerro(Perro):

    def __init__(self, nombre, edad):
        super().__init__(nombre, edad)

    def sonido(self):
        print("WOOOOOOOOOOOFFFF")

    def dar_vueltas(self):
        print(self.nombre, "se ha dado la vuelta")

    def dar_la_pata(self):
        print(self.nombre, "te ha dado la pata !")

Nuestro main quedaria así

# main.py
from animales.animales import Perro
from animales.super_perro import SuperPerro

mi_perro = SuperPerro('firulais',5)
tu_perro = Perro('Rolf',15)

tu_perro.sentarse()
mi_perro.sentarse()
mi_perro.cumpleanos()
print(mi_perro.edad)

tu_perro.sonido()
mi_perro.sonido()

mi_perro.dar_la_pata()